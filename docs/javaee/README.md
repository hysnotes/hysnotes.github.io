# abstract

## 抽象类：

所谓的抽象类，就是我们不想具体化一个类型所封装出来的类型

被abstract修饰的类，被称为抽象类，此类不能new对象

抽象类意为不够完整的类、不够具体的类，抽象类对象无法独立存在，即不能new对象

作用：

- 可被子类继承，提供共性属性和方法
- 可声明为引用，更自然的使用多态

经验：

​	抽象父类，可作为子类的组成部分依附于子类对象存在，由父类共性+子类独有组成完整的子类对象

特点：

- 抽象类不能new 对象，但可以声明变量，可以被子类继承
- 抽象类中可以包含属性和非抽象方法，也可以包含抽象方法
- 抽象类中有参构造方法，但是不能实例化，只能被子类调用
- 抽象类存在的意义就是用来被继承或扩展的
- 抽象类的子类不一定非要实现父类型的抽象方法，它可以继续声明自己也是抽象的

## 抽象方法

概念：被abstract修饰的方法，被称为抽象方法（没有具体实现（方法体））

产生继承关系后，子类必须重写父类中所有的抽象方法，否则子类还是抽象类

特点：

- 抽象方法只有方法声明，没有方法体
- 包含抽象方法的类一定是抽象类
- 抽象方法必须被子类重写，除非子类也是抽象类

# 接口

定义：相当于特殊的抽象类，定义方法、组成部分与抽象类类似

特点：

- 使用**interface**关键字定义接口
- 没有构造方法，不能创建对象
- 只能定义：公开静态常量、公开抽象方法

注：接口中其实可以定义具体的方法（默认方法，也可以定义多个），前面必须加default修饰

**实现接口**

由于接口没有构造方法，不能创建对象，需要实现类实现接口

实现接口：使用**implements**关键字

**与抽象类的区别**

相同：

- 可编译成字节码文件
- 不能创建对象
- 都可以声明变量(引用)
- 隐式具备Object类中所定义的方法

不同：

- 接口所有属性都是公开静态变量，隐式使用public static final修饰
- 接口所有方法都是公开抽象方法，隐式使用public abstract修饰
- 接口没有构造方法、动态代码块、静态代码块
- 抽象类没有限制

什么是接口

微观概念：接口是一种能力和阅约定。

- 接口的定义：代表了某种能力
- 方法的定义：能力的具体要求

经验：Java为单继承，当父类的方法种类无法满足子类需求时，可实现接口扩充子类能力。

接口支持多实现，可为类扩充多种能力。

**接口与其他类型之间的关系**

- 接口与实现类之间的是implements
- 接口与接口直接之间是extends

**分类**

常量接口：将多个常用于表示状态或固定值的变量，以静态常量的形式定义在接口中统一管理，提高代码可读性

标记接口：接口没有任何成员，仅仅是一个标记。Serializable、Clone able

**好处**

- 降低程序的耦合性
- 更自然的使用多态
- 设计与实现完全分离
- 更容易搭建程序框架
- 更容易更换具体实现

# final

final 关键字时最终的意思，可以修饰成员方法、成员变量、类

final 修饰的特点

- 修饰方法：表明该方法时最终方法，**不能被重写**
- 修饰变量：表明该变量是常量，**不能再次被赋值**,但是可以在构造方法处进行第一次赋值
- 修饰类：表明该类是最终类，**不能被继承**

final修饰局部变量

- 变量是基本类型：final修饰指的是基本类型的数据值不能发生改变
- 变量是引用类型：final修饰指的是引用类型的地址值不能发生改变，但是地址里面的内容是可以发生改变的

# Static

static 关键字是静态的意思，可以修饰成员方法，成员变量

Static 修饰的特点

- 被类的所以对象共享，

  这也是我们判断是否使用静态关键字的条件

- 可以通过类名调用

  当然，也可以通过对象名调用

  **推荐使用类名调用**

static修饰特点

非静态的成员方法

- 能访问静态的成员变量
- 能访问非静态的成员变量
- 能访问静态的成员方法
- 能访问非静态的成员变量

静态的成员方法

- 能访问静态的成员变量
- 能访问静态的成员方法

**总结成一句话就是：静态成员方法只能访问静态成员**

